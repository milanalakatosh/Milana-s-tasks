//Dано n кирпичей. Вы и компьютер ходите поочередно. за ход можно взять 1, 2 или 3 кирпича. 
//Проиграл тот, кому нечего брать. Реализуйте игру с компьютером. 
//Компьютер ходит случайно (без анализа выигрышной стратегии), однако если у него есть ход, 
//который является последним для его выигрыша, то он его совершает.
//КАК БЫТЬ В СИТУАЦИИ, КОГДА КОМПЬТЕР ХОДИТ ПРИ ОСТАТКЕ 6 КИРПИЧЕй?ЕСЛИ ОН ВОЗЬМЕТ 1-2 КИРПИЧА, ОН ВЫЙГРАЕТ, ЕСЛИ 3 , ТО ПРОИГРАЕТ
const readlineSync = require("readline-sync");

let n = parseInt(readlineSync.question("Введите количество кирпичей: "));
let myStep = 0;
let compStep = 0;

while (n > 0) {
    if (n > 3) {// или прописать n>6 || n ===4?
        compStep = Math.floor((Math.random() * 3)+1);
        n -= compStep;
        console.log("Компьютер берет " + compStep + " кирпич(-а), осталось " + n)
    } else {
        console.log("Компьютер берет " + n + " кирпич(-а), компьютер выйграл.");
        break;
    }

    if (n > 3) {
        myStep = parseInt(readlineSync.question("Сколько взять кирпичей?\n> "));
        if (myStep > 3 || myStep < 1) {
            console.log("неправильно");
            break; //есть ли метод, который не выбрасывает из цикла, а отбрасывает на один шаг назад?
        }
    } else {
        console.log("Я выйграла!!!!!!");
        break;
    }
    n -= myStep;
}
